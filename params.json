{
  "name": "C/C++------const用法，尽可能使用const",
  "tagline": "静静向上的博客",
  "body": "[转载链接](http://www.cnblogs.com/xudong-bupt/p/3509567.html)\r\n\r\n# C++ const用法 尽可能使用const \r\n　　C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。\r\n\r\n1.const 修饰成员变量 \r\n\r\n\r\n` 1 #include<iostream>`\r\n `2 using namespace std;`\r\n `3 int main(){`\r\n `4     int a1=3;   ///non-const data`\r\n `5     const int a2=a1;    ///const data`\r\n `6 `\r\n `7     int * a3 = &a1;   ///non-const data,non-const pointer`\r\n `8     const int * a4 = &a1;   ///const data,non-const pointer`\r\n `9     int * const a5 = &a1;   ///non-const data,const pointer`\r\n`10     int const * const a6 = &a1;   ///const data,const pointer`\r\n`11     const int * const a7 = &a1;   ///const data,const pointer`\r\n`12 `\r\n`13     return 0;`\r\n`14 }`\r\nconst修饰指针变量时：\r\n\r\n　　(1)只有一个const，如果const位于*左侧，表示指针所指数据是常量，不能通过解引用修改该数据；指针本身是变量，可以指向其他的内存单元。\r\n\r\n　　(2)只有一个const，如果const位于*右侧，表示指针本身是常量，不能指向其他内存地址；指针所指的数据可以通过解引用修改。\r\n\r\n　　(3)两个const，*左右各一个，表示指针和指针所指数据都不能修改。\r\n\r\n2.const修饰函数参数\r\n\r\n　　传递过来的参数在函数内不可以改变，与上面修饰变量时的性质一样。\r\n\r\n`void testModifyConst(const int _x) {`\r\n     `_x=5;　　　///编译出错`\r\n`}`\r\n\r\n3.const修饰成员函数\r\n\r\n(1)const修饰的成员函数不能修改任何的成员变量(mutable修饰的变量除外)\r\n\r\n(2)const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量\r\n\r\n\r\n` 1 #include <iostream>`\r\n `2 using namespace std;`\r\n `3 class Point{`\r\n `4     public :`\r\n `5     Point(int _x):x(_x){}`\r\n `6 `\r\n `7     void testConstFunction(int _x) const{`\r\n `8 `\r\n `9         ///错误，在const成员函数中，不能修改任何类成员变量`\r\n`10         x=_x;`\r\n`11 `\r\n`12         ///错误，const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量`\r\n`13         modify_x(_x);`\r\n`14     }`\r\n`15 `\r\n`16     void modify_x(int _x){`\r\n`17         x=_x;`\r\n`18     }`\r\n`19 `\r\n`20     int x;`\r\n`21 };`\r\n\r\n 4.const修饰函数返回值\r\n\r\n(1)指针传递\r\n\r\n如果返回const data,non-const pointer，返回值也必须赋给const data,non-const pointer。因为指针指向的数据是常量不能修改。\r\n\r\n\r\n` 1 const int * mallocA(){  ///const data,non-const pointer`\r\n `2     int *a=new int(2);`\r\n `3     return a;`\r\n `4 }`\r\n `5 `\r\n `6 int main()`\r\n `7 {`\r\n `8     const int *a = mallocA();`\r\n `9     ///int *b = mallocA();  ///编译错误`\r\n`10     return 0;`\r\n`11 }`\r\n\r\n(2)值传递\r\n\r\n 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。所以，对于值传递来说，加const没有太多意义。\r\n\r\n所以：\r\n\r\n　　不要把函数int GetInt(void) 写成const int GetInt(void)。\r\n　　不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。\r\n\r\n \r\n\r\n　　在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}